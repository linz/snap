/*************************************************************************
**
**  Filename:    %M%
**
**  Version:     %I%
**
**  What string: %W%
**
** $Id: dbl4_utl_trig.c,v 1.3 2005/04/04 23:57:58 ccrook Exp $
**//**
** \file
**      Functions for managing a triangulated function defined in a
**      custom binary format (generated by maketrig.pl).  This implementation
**      (and the format?) is reliable only for convex triangulated regions.
**      The triangulation file is broken into blocks indexed by a binary
**      tree.  The design is intended to facilitate caching of the data in
**      memory if the triangulation is large enough to require this.
**      The indexing identifies an initial triangle the centre of which
**      is close to the evaluation point.  The triangulation is then traversed
**      by crossing boundaries to nearer triangles to locate the enclosing
**      triangle.  The traversal process may fail if the boundary is not
**      convex.
**
**      The main objects used in this are as follows:
**         TrigDef         The overall triangulation object
**         TrigBlock       A block of triangle definitions loaded as
**                         a unit
**         TriangleDef     Definition of a single triangle
**         SplitIndex      A simplistic binary spatial index used to
**                         index the TrigBlock's in the TrigDef, and
**                         the triangles in each TrigBlock
**
**      This code is not thread-safe in that the same triangulation
**      definition cannot be used simultaneously in multiple threads.
**
**      The binary format is portable between SUN and Intel DOS/Windows
**      environments which differ only in endianness
**
*************************************************************************
*/

#include "dbl4_common.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "dbl4_utl_trig.h"

#include "dbl4_utl_alloc.h"
#include "dbl4_utl_error.h"

/* Maximum number of rows stored in triangle block cache */

#define MAGIC_NUMBER 0x8E215AA7

/* Definition of the complete triangulation structure */

/* ptxy is an array of doubles containing the coordinates of each point (x1,y1,x2,y2,...)
   ptdata is an array of doubles containing the ndim data values for each point (p1v1,p1v2,..p2v1,p2v2, ..)
   pttopoidx is an array defining the location in topodata of the data for each point
   topodata is an array containing for each point the number of surrounding nodes, the ids of the
      surrounding nodes, and the id of the opposite triangle node across the edge between the
	  corresponding and next surrounding node.  ids are all 1 based.  an opposited triangle node
	  id 0 implies that there is no opposite triangle node, and a surrounding node id of 0 implies
	  a break in the triangulation (ie the boundary of the triangulation). */

typedef struct
{
    INT4 magic;
    char *desc1;
    char *desc2;
    char *desc3;
    char *crdsys;
    double maxy;
    double miny;
    double maxx;
    double minx;
    short npts;
    short ndim;
    INT4 narray;
    double *ptxy;
    double *ptdata;
    INT4 *pttopoidx;
    INT2 *topodata;
} TrigDef, *hTrigDef;

typedef struct
{
    short id;
    short nnode;
    double *xy;
    double *data;
    short *nodeid;
    short *opposite;
} PointDef, *hPointDef;


typedef struct
{
    PointDef pts[3];
} TriangleDef, *hTriangleDef;


/*************************************************************************
** Function name: find_nearest
**//**
**    Finds the nearest node in the triangulation to a test point.  Uses
**    a binary search which assumes nodes are in order of ascending x
**    coordinate.  Uses a rectangular distance measure for computational
**    efficiency.
**
**  \param trig                The triangle definition
**  \param ptx                 The x coordinate of the test point
**  \param pty                 The y coordinate of the test point
**
**  \return                    The node id of the nearest node
**
**************************************************************************
*/


static short find_nearest( hTrigDef trig, double ptx, double pty )
{
    double offset;
    double x0,x1;
    short i0,i1,im;

    double *xy = trig->ptxy;
    int npts = trig->npts;

    /* Use bisection to determine the immediately lower node in terms
       of the sorted x coordinates */

    i0 = 0;
    x0 = xy[0];
    if( ptx <= x0 ) return i0;
    i1 = npts-1;
    x1 = xy[i1*2];
    if( ptx >= x1 ) return i1;

    while( i0 < i1-1 )
    {
        int im = (i0+i1)/2;
        double xm = xy[im*2];
        if( ptx < xm )
        {
            x1 = xm;
            i1 = im;
        }
        else
        {
            x0 = xm;
            i0 = im;
        }
    }

    /* Expand out from this point in each direction to find the nearest
       node.  Using simple non-euclidean distance measure.  Some scope
       for extra efficiency by using and offsetting double pointers.

       For each direction of search, up and down from start point
       if the offset in the x direction exceeds the distance to the
       current nearest point, then stop searching in that direction.
    */

    im = i0;
    offset = (ptx - x0) + fabs(xy[i0*2+1]-pty);
    i0--;

    while(i0 >= 0 || i1 < npts)
    {
        if( i0 >=0 )
        {
            double o = ptx - xy[i0*2];
            if( o > offset )
            {
                i0 = 0;
            }
            else
            {
                o += fabs(pty-xy[i0*2+1]);
                if( o < offset )
                {
                    im = i0;
                    offset = o;
                }
            }
            i0--;
        }

        if( i1 < npts )
        {
            double o = xy[i1*2]-ptx;
            if( o > offset )
            {
                i1 = npts;
            }
            else
            {
                o += fabs(pty-xy[i1*2+1]);
                if( o < offset )
                {
                    im = i1;
                    offset = o;
                }
            }
            i1++;
        }
    }

    return im+1;  /* Point numbers are 1 based - array locations are 0 based */
}

/*************************************************************************
** Function name: get_point
**//**
**    Assembles the data for a triangulation node based on its node id.
**
**  \param trig                The triangle definition
**  \param npt                 The id of the node
**  \param pt                  Returns the data for the point
**
**  \return                    The return status
**
**************************************************************************
*/

static hPointDef get_point( hTrigDef trig, int npt, hPointDef pt )
{
    short *ptr;
    pt->id = npt;
    npt--;
    pt->xy = trig->ptxy+2*npt;
    pt->data = trig->ptdata+trig->ndim*npt;
    ptr = trig->topodata + trig->pttopoidx[npt];
    pt->nnode = *ptr;
    ptr++;
    pt->nodeid = ptr;
    ptr += pt->nnode;
    pt->opposite = ptr;
    return pt;
}

/*************************************************************************
** Function name: find_triangle
**//**
**    Search for the triangle in a triangulation that contains the
**    point being tested.
**
**    This code will only be guaranteed to work with a convex triangulated
**    region
**
**  \param trig                The triangle definition
**  \param xt                  The test point x coordinate
**  \param yt                  The test point y coordinate
**  \param triangle            Returns the triangle holding the point
**
**  \return                    The return status
**
**************************************************************************
*/

static int find_triangle( hTrigDef trig, double xt, double yt, hTriangleDef triangle )
{
    double x, y, xp, yp, x2, y2, x3, y3, dp2, dp3;
    short ptid,pt1id,pt2id,pt3id,plast;
    int finished;
    int nnode,i;
    int maxiterations;
    hPointDef pp1, pp2, pp3;

    if( xt < trig->minx || xt > trig->maxx ||
            yt < trig->miny || yt > trig->maxy )
    {
        RETURN_STATUS( STS_CRD_RANGE_ERR );
    }

    if (trig->npts<3) RETURN_STATUS(STS_INVALID_DATA);

    pp1 = &(triangle->pts[0]);
    pp2 = &(triangle->pts[1]);
    pp3 = &(triangle->pts[2]);

    ptid = find_nearest( trig, xt, yt );
    if( ptid == 0 )
    {
        TRACE_TRIG2(("find_triangle: Base point not found"));
        RETURN_STATUS(STS_CRD_RANGE_ERR);
    }
    get_point(trig,ptid,pp1);
    plast = pt1id = ptid;

    TRACE_TRIG2(("find_triangle: Base point %d (%.6lf %.6lf)",(int) pt1id, pp1->xy[0],pp1->xy[2]));

    finished = 0;
    maxiterations = trig->npts;
    if (xt==pp1->xy[0] && yt==pp1->xy[1] )
    {
        ptid = pp1->nodeid[0];
        if( ptid == 0 ) RETURN_STATUS(STS_INVALID_DATA);
        get_point(trig,ptid,pp2);

        ptid = pp1->nodeid[1];
        if( ptid == 0 ) RETURN_STATUS(STS_INVALID_DATA);
        get_point(trig,ptid,pp3);
    }

    else do
        {
            if( maxiterations-- <= 0 )
            {
                THROW_EXCEPTION("Corrupt triangulation or code error in find_triangle");
                RETURN_STATUS( STS_INVALID_DATA );
            }
            nnode = pp1->nnode;

            xp = pp1->xy[0];
            yp = pp1->xy[1];
            x = xt-xp;
            y = yt-yp;

            pt3id = pp1->nodeid[nnode-1];
            x3 = 0;
            y3 = 0;
            dp3 = 0;
            if( pt3id > 0 )
            {
                get_point(trig,pt3id,pp3);
                x3 = pp3->xy[0] - xp;
                y3 = pp3->xy[1] - yp;
                dp3 = x*y3 - y*x3;
            }

            finished = 2;
            for (i=0; i<nnode; i++)
            {
                hPointDef tmp = pp3;
                pp3 = pp2;
                pp2 = tmp;
                x2 = x3;
                y2 = y3;
                dp2 = dp3;
                pt2id = pt3id;

                pt3id = pp1->nodeid[i];
                if( pt3id > 0 )
                {
                    get_point(trig,pt3id,pp3);
                    x3 = pp3->xy[0] - xp;
                    y3 = pp3->xy[1] - yp;
                    dp3 = x*y3 - y*x3;
                }

                if( pt2id == 0 || pt3id == 0 ) continue;

                /* If the angle between the two points includes the test point,
                   check whether it is inside the triangle, and exit the loop.
                   If the search needs to proceed to an adjacent triangle,
                   then reset p1 */

                if( dp2 <=0 && dp3 > 0 )
                {
                    x3 -= x2;
                    y3 -= y2;
                    x -= x2;
                    y -= y2;
                    if (x3*y-y3*x >= 0) finished = 1;
                    else
                    {
                        ptid = pp1->opposite[i == 0 ? nnode-1 : i-1];
                        /* Check for flip-flopping across an edge */
                        if(ptid == 0 )
                        {
                            RETURN_STATUS(STS_CRD_RANGE_ERR);
                        }
                        if(ptid != plast)
                        {
                            plast = pt1id;
                            pt1id = ptid;
                            get_point(trig,ptid,pp1);
                            TRACE_TRIG2(("find_triangle: New base point %d (%.6lf %.6lf)",(int) pt1id, pp1->xy[0],pp1->xy[2]));
                            finished = 0;
                        }
                        else
                        {
                            finished = 1;
                        }
                    }
                    break;
                }
            }
            if( finished == 2 )
            {
                RETURN_STATUS(STS_CRD_RANGE_ERR);
            }
        }
        while ( ! finished );
    return STS_OK;
}



/*************************************************************************
** Function name: calc_triangle_value
**//**
**    Calculates the data values at a specific point in the triangulation
**
**  \param trig                The triangle definition
**  \param x                   The x coordinate of the test point
**  \param y                   The y coordinate of the test point
**  \param value               An array of doubles receiving one
**                             or more results depending upon the
**                             dimension of the triangulation data.
**
**  \return                    The return status
**
**************************************************************************
*/

static StatusType calc_triangle_value( hTrigDef trig, double x, double y,
                                       double *value )
{
    TriangleDef trd;
    hTriangleDef tr = &trd;
    StatusType sts;
    short ndim = trig->ndim;
    short p, i;
    double *xy1, *xy2, *xy3;
    double m[3];
    double a;

    for( i = 0; i < ndim; i++ ) value[i] = 0.0;

    sts = find_triangle( trig, x, y, tr );
    if( sts != STS_OK ) RETURN_STATUS( sts );

    xy1 = tr->pts[0].xy;
    xy2 = tr->pts[1].xy;
    xy3 = tr->pts[2].xy;

    a = (xy1[0]-xy2[0])*(xy3[1]-xy2[1])+(xy1[1]-xy2[1])*(xy2[0]-xy3[0]);
    m[0] = ((x-xy2[0])*(xy3[1]-xy2[1]) + (y-xy2[1])*(xy2[0]-xy3[0]))/a;
    m[1] = ((x-xy3[0])*(xy1[1]-xy3[1]) + (y-xy3[1])*(xy3[0]-xy1[0]))/a;
    m[2] = ((x-xy1[0])*(xy2[1]-xy1[1]) + (y-xy1[1])*(xy1[0]-xy2[0]))/a;

    TRACE_TRIG2(("calc_triangle_value: point %d (%.6lf %.6lf) multiplier %.6f",
                 tr->pts[0].id, xy1[0],xy1[1],m[0]));
    TRACE_TRIG2(("calc_triangle_value: point %d (%.6lf %.6lf) multiplier %.6f",
                 tr->pts[1].id, xy2[0],xy2[1],m[1]));
    TRACE_TRIG2(("calc_triangle_value: point %d (%.6lf %.6lf) multiplier %.6f",
                 tr->pts[2].id, xy3[0],xy3[1],m[2]));

    for( p = 0; p < 3; p++ )
    {
        double *d = tr->pts[p].data;
        for( i = 0; i < ndim; i++, d++ )
        {
            value[i] += m[p]*(*d);
        }
    }

    for( i = 0; i < ndim; i++ )
    {
        TRACE_TRIG2(("calc_triangle_value: dim %d value %.8le",
                     i,value[i]));
    }

    return STS_OK;
}


/*************************************************************************
** Function name: delete_trig_def
**//**
**         Deletes a TrigDef object and deallocates the resources it uses
**
**  \param trig                The object to delete
**
**  \return
**
**************************************************************************
*/

static void delete_trig_def( hTrigDef trig)
{
    trig->magic = 0;
    if( trig->desc1 )
    {
        utlFree( trig->desc1 );
        trig->desc1 = 0;
    }
    if( trig->desc2 )
    {
        utlFree( trig->desc2 );
        trig->desc2 = 0;
    }
    if( trig->desc3 )
    {
        utlFree( trig->desc3 );
        trig->desc3 = 0;
    }
    if( trig->crdsys )
    {
        utlFree( trig->crdsys );
        trig->crdsys = 0;
    }
    if( trig->ptdata )
    {
        utlFree( trig->ptdata );
        trig->ptdata = 0;
    }
    if( trig->ptxy )
    {
        utlFree( trig->ptxy );
        trig->ptxy = 0;
    }
    if( trig->pttopoidx )
    {
        utlFree( trig->pttopoidx );
        trig->pttopoidx = 0;
    }
    if( trig->topodata )
    {
        utlFree( trig->topodata );
        trig->topodata = 0;
    }
    utlFree( trig );
}


/*************************************************************************
** Function name: check_header
**//**
**    Reads the triangulation header from a binary data source and checks
**    that it is compatible with the one of the defined valid headers.
**    Each header defines a version of the triangulation format
**
**  \param binsrc              The binary data source to read from
**
**  \return                    Returns the grid format version number
**
**************************************************************************
*/

static int check_header( hBinSrc binsrc)
{
    char buf[80];
    INT4 len;
    int version;
    int big_endian=0;
    version = 0;
    len = strlen( TRGDAT_FILE_HEADER_1 );
    if( utlBinSrcLoad1( binsrc, 0, len, buf ) != STS_OK ) return 0;

    if(  memcmp( buf, TRGDAT_FILE_HEADER_1, len ) == 0 )
    {
        version = 1;
        big_endian = 0;
    }
    else if(  memcmp( buf, TRGDAT_FILE_HEADER_2, len ) == 0 )
    {
        version = 1;
        big_endian = 1;
    }
    utlBinSrcSetBigEndian( binsrc, big_endian );

    return version;
}




/*************************************************************************
** Function name: create_trig_def
**//**
**   Function to load the data defining a grid (ie extents, number of cells,
**   etc)
**
**  \param ptrig               The triangulation object to load
**  \param binsrc              The binary data source to load the
**                             triangulation from
**
**  \return                    The return status
**
**************************************************************************
*/

static short create_trig_def( hTrigDef* ptrig, hBinSrc binsrc)
{
    hTrigDef trig;
    int version;
    INT2 ival;
    INT4 ival4;
    StatusType sts;

    /*> Check that the header and get the format version with check_header */

    TRACE_TRIG(("create_trig_def"));
    version = check_header(binsrc);
    TRACE_TRIG(("create_trig_def: version %d",version));
    if( ! version )
    {
        RETURN_STATUS(STS_INVALID_DATA);
    }

    /*> Allocate a TrigDef object with utlAlloc */

    trig = (hTrigDef) utlAlloc( sizeof( TrigDef ) );
    if( ! trig ) RETURN_STATUS(STS_ALLOC_FAILED);

    /*> Initiallize the object */

    trig->desc1 = 0;
    trig->desc2 = 0;
    trig->desc3 = 0;
    trig->crdsys = 0;
    trig->ptxy = 0;
    trig->ptdata = 0;
    trig->pttopoidx = 0;
    trig->topodata = 0;
    sts = STS_OK;

    /*> Load the triangulation descriptive information */

    if( sts == STS_OK )
        sts = utlBinSrcLoadString( binsrc, BINSRC_CONTINUE, &(trig->desc1) );
    if( sts == STS_OK )
        sts = utlBinSrcLoadString( binsrc, BINSRC_CONTINUE, &(trig->desc2) );
    if( sts == STS_OK )
        sts = utlBinSrcLoadString( binsrc, BINSRC_CONTINUE, &(trig->desc3) );
    if( sts == STS_OK )
        sts = utlBinSrcLoadString( binsrc, BINSRC_CONTINUE, &(trig->crdsys) );

    TRACE_TRIG(("create_trig_def: desc1      %s",trig->desc1));
    TRACE_TRIG(("create_trig_def: desc2      %s",trig->desc2));
    TRACE_TRIG(("create_trig_def: desc3      %s",trig->desc3));
    TRACE_TRIG(("create_trig_def: crdsys     %s",trig->crdsys));

    /*> Load the index data from the binary source with utlBinSrcLoad8,
        utlBinSrcLoad4, utlBinSrcLoad2, and utlBinSrcLoadString */

    if( sts == STS_OK ) sts = utlBinSrcLoad8( binsrc, BINSRC_CONTINUE, 1, (void *) (&(trig->miny)) );
    if( sts == STS_OK ) sts = utlBinSrcLoad8( binsrc, BINSRC_CONTINUE, 1, (void *) (&(trig->maxy)) );
    if( sts == STS_OK ) sts = utlBinSrcLoad8( binsrc, BINSRC_CONTINUE, 1, (void *) (&(trig->minx)) );
    if( sts == STS_OK ) sts = utlBinSrcLoad8( binsrc, BINSRC_CONTINUE, 1, (void *) (&(trig->maxx)) );

    TRACE_TRIG(("create_trig_def: range %lf %lf %lf %lf",trig->minx,trig->maxx,
                trig->miny,trig->maxy));

    if( sts == STS_OK ) sts = utlBinSrcLoad2( binsrc, BINSRC_CONTINUE, 1, &ival );
    trig->npts = ival;
    if( sts == STS_OK ) sts = utlBinSrcLoad2( binsrc, BINSRC_CONTINUE, 1, &ival );
    trig->ndim = ival;
    if( sts == STS_OK ) sts = utlBinSrcLoad4( binsrc, BINSRC_CONTINUE, 1, &ival4 );
    trig->narray = ival4;

    TRACE_TRIG(("create_trig_def: npts       %hd",trig->npts));
    TRACE_TRIG(("create_trig_def: ndim       %hd",trig->ndim));
    TRACE_TRIG(("create_trig_def: narray     %hd",trig->narray));

    if( sts == STS_OK && trig->npts <= 0 )
    {
        SET_STATUS(sts,STS_INVALID_DATA);
    }
    if( sts == STS_OK && trig->ndim <= 0 )
    {
        SET_STATUS(sts,STS_INVALID_DATA);
    }
    if( sts == STS_OK && trig->ndim > 10 )
    {
        SET_STATUS(sts,STS_INVALID_DATA);
    }
    if( sts == STS_OK && trig->narray < trig->npts*5 )
    {
        SET_STATUS(sts,STS_INVALID_DATA);
    }
    /*> Create and load a SplitIndex that spatially indexes the blocks in
        the object */

    if( sts == STS_OK )
    {
        trig->ptxy = (double *) utlAlloc( 2 * trig->npts * sizeof(double) );
        if( !trig->ptxy ) SET_STATUS(sts,STS_ALLOC_FAILED);
    }

    if( sts == STS_OK )
    {
        trig->ptdata = (double *) utlAlloc( trig->ndim * trig->npts * sizeof(double) );
        if( !trig->ptdata ) SET_STATUS(sts,STS_ALLOC_FAILED);
    }

    if( sts == STS_OK )
    {
        trig->pttopoidx = (INT4 *) utlAlloc( trig->npts * sizeof(INT4) );
        if( !trig->pttopoidx ) SET_STATUS(sts,STS_ALLOC_FAILED);
    }

    if( sts == STS_OK )
    {
        trig->topodata = (INT2 *) utlAlloc( trig->narray * sizeof(INT2));
        if( !trig->topodata ) SET_STATUS(sts,STS_ALLOC_FAILED);
    }

    if( sts == STS_OK ) sts = utlBinSrcLoad8( binsrc, BINSRC_CONTINUE, 2*trig->npts, (void *) (trig->ptxy) );
    if( sts == STS_OK ) sts = utlBinSrcLoad8( binsrc, BINSRC_CONTINUE, trig->ndim*trig->npts, (void *) (trig->ptdata) );
    if( sts == STS_OK ) sts = utlBinSrcLoad4( binsrc, BINSRC_CONTINUE, trig->npts, (void *) (trig->pttopoidx) );
    if( sts == STS_OK ) sts = utlBinSrcLoad2( binsrc, BINSRC_CONTINUE, trig->narray, (void *) (trig->topodata) );

    if( sts != STS_OK )
    {
        delete_trig_def(trig);
        trig = 0;
        RETURN_STATUS(sts);
    }

    /*> Otherwise set its "magic number" signature, and return a
        success status */

    trig->magic = MAGIC_NUMBER;
    *ptrig = trig;
    return STS_OK;
}


/*************************************************************************
** Function name: trig_def_from_handle
**//**
**    Casts a void pointer to a hTrigDef*, and checks that the "magic
**    number" (ie signature) is correct
**
**  \param handle              pointer to cast
**
**  \return                    Returns the trig_def or null
**
**************************************************************************
*/

static hTrigDef trig_def_from_handle( void *handle)
{
    hTrigDef def;
    if( ! handle ) return 0;
    def = (hTrigDef) handle;
    if( def->magic != (INT4) MAGIC_NUMBER ) return 0;
    return def;
}


/*************************************************************************
** Function name: utlCreateTrig
**//**
**       Function to create a trig handle.  This function uses a hBinSrc to
**       identify a data source.  It does not take over management of the
**       hBlob.  It is up the the user to ensure that the hBlob remains
**       valid for the duration of the trig handle.
**
**  \param binsrc              Binary data source for trig data
**  \param trig                Trig handle returned (0 if fails)
**
**  \return                    Returned status
**
**************************************************************************
*/

StatusType utlCreateTrig( hBinSrc binsrc, hTrig *trig)
{
    hTrigDef def;
    StatusType sts;

    def=0;
    *trig = 0;
    sts = create_trig_def( &def, binsrc );
    if( sts == STS_OK ) *trig =  (void *) def;
    TRACE_TRIG(("utlCreateTrig %lX",(unsigned long) *trig));
    return sts;
}


/*************************************************************************
** Function name: utlReleaseTrig
**//**
**    Function releases a trig.
**
**  \param trig                The trig to release
**
**  \return                    The return status
**
**************************************************************************
*/

StatusType utlReleaseTrig( hTrig trig)
{
    hTrigDef def;
    TRACE_TRIG(("utlReleaseTrig %lX",(unsigned long) trig));
    def = trig_def_from_handle( trig );
    if( ! def ) RETURN_STATUS(STS_INVALID_HANDLE);
    delete_trig_def(def);
    return STS_OK;
}


/*************************************************************************
** Function name: utlTrigVectorDimension
**//**
**       Return the number of elements defined at each trig point (ie
**       dimension of the vector field that the trig defines).
**
**  \param trig                Trig handle
**  \param dimension           Returns the dimension
**
**  \return                    Return status
**
**************************************************************************
*/

StatusType utlTrigVectorDimension( hTrig trig, int *dimension)
{
    hTrigDef def;
    def = trig_def_from_handle( trig );
    if( ! def ) RETURN_STATUS(STS_INVALID_HANDLE);
    *dimension = def->ndim;
    return STS_OK;
}


/*************************************************************************
** Function name: utlTrigCoordSysDef
**//**
**       Returns a coordinate system code stored in the trig.  This is not
**       particularly relevent to CRS as it is currently defined.
**
**  \param trig                The trig handle
**  \param crdsys              Returns a pointer to the string
**
**  \return                    Return status
**
**************************************************************************
*/

StatusType utlTrigCoordSysDef( hTrig trig, char** crdsys)
{
    hTrigDef def;
    def = trig_def_from_handle( trig );
    if( ! def ) RETURN_STATUS(STS_INVALID_HANDLE);
    *crdsys = def->crdsys;
    return STS_OK;
}


/*************************************************************************
** Function name: utlTrigTitle
**//**
**       Returns one of up to three lines of text defined with the trig.
**       Generally used for descriptive information about the trig.
**
**  \param trig                The trig handle
**  \param nTitle              The number of the text required (1-3)
**  \param title               Returns a pointer to the text
**
**  \return                    Return status
**
**************************************************************************
*/

StatusType utlTrigTitle( hTrig trig, int nTitle, char** title)
{
    hTrigDef def;
    def = trig_def_from_handle( trig );
    if( ! def ) RETURN_STATUS(STS_INVALID_HANDLE);
    *title = 0;
    switch( nTitle )
    {
    case 1:
        *title = def->desc1;
        break;
    case 2:
        *title = def->desc2;
        break;
    case 3:
        *title = def->desc3;
        break;
    default:
        RETURN_STATUS(STS_INVALID_DATA);
    }
    return STS_OK;
}

/*************************************************************************
** Function name: utlCalcTrig
**//**
**       Calculates the value at a location within the trig using bilinear
**       interpolation.  Simply validates the handle and calls
**       ::calc_triangle_value.
**
**  \param trig                The trig handle
**  \param x                   The x coordinate at which to calculate
**  \param y                   The y coordinate at which to calculate
**  \param value               The array of returned values (the
**                             number of values is as specified in
**                             utlTrigVectorDimension.
**
**  \return                    The return status
**
**************************************************************************
*/

StatusType utlCalcTrig( hTrig trig, double x, double y, double *value)
{
    hTrigDef def;
    StatusType sts;
    def = trig_def_from_handle( trig );
    if( ! def ) RETURN_STATUS(STS_INVALID_HANDLE);

    TRACE_TRIG(("utlCalcTrig: %lX %lf %lf",(unsigned long) trig,x,y));

    sts = calc_triangle_value( def, x, y, value );

    TRACE_TRIG(("utlCalcTrig: sts %d value[0] %lf",(int) sts, value[0] ));

    return sts;
}


/*

#define PRINT(x) (*printfunc)(obj,x)

StatusType utlDumpTrig( hTrig trig, void *obj, void (*printfunc)( void *obj, const char *s ) )
{
    hTrigDef def;
    char buf[256];
    int i, j;
    double *xy, *data;

    def = trig_def_from_handle( trig );
    if( ! def ) RETURN_STATUS(STS_INVALID_HANDLE);

    PRINT("Desc1:  ");
    PRINT( def->desc1 );
    PRINT("\n");
    PRINT("Desc2:  ");
    PRINT( def->desc2 );
    PRINT("\n");
    PRINT("Desc3:  ");
    PRINT( def->desc3 );
    PRINT("\n");
    PRINT("Crdsys: ");
    PRINT( def->crdsys );
    PRINT("\n");
    sprintf(buf,"Points: %d\nDimension: %d\n",def->npts,def->ndim);
    PRINT(buf);
    for( i = 1, xy = def->ptxy, data=def->ptdata; i <= def->npts; i++, xy+=2 )
    {
        sprintf(buf,"Point: %4d %12.6lf %12.6lf",i,xy[0],xy[1]);
        PRINT(buf);
        for( j = 0; j < def->ndim; j++ )
        {
            sprintf(buf," %12.6lf",*data++);
            PRINT(buf);
        }
        PRINT("\n");
    }
    for( i = 1; i <= def->npts; i++ )
    {
        INT4 idx = def->pttopoidx[i-1];
        short *s = def->topodata+idx;
        short *nd = s+1;
        short *op = nd+s[0];

        sprintf(buf,"Topology: %4d at %5ld, %d nodes: ",i,(long) idx,(int)s[0]);
        PRINT(buf);
        for( j = 0; j < s[0]; j++ )
        {
            sprintf(buf," %d -<%d>-",(int) nd[j], (int) op[j]);
            PRINT(buf);
        }
        PRINT("\n");
    }
    return STS_OK;
}
*/
